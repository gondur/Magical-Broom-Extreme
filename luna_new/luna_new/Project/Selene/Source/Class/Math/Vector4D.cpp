

//-----------------------------------------------------------------------------------
// INCLUDE
//-----------------------------------------------------------------------------------
#include "Base.h"		// PCH

#include "Math/Math.h"
#include "Math/Vector4D.h"
#include "Math/Matrix.h"


//-----------------------------------------------------------------------------------
// NAMESPACE
//-----------------------------------------------------------------------------------
using namespace Selene;


//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D::CVector4D()
{
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D::CVector4D( const CVector3D &v )
{
	this->x = v.x;
	this->y = v.y;
	this->z = v.z;
	this->w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D::CVector4D( const CVector4D &v )
{
	*this = v;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D::CVector4D( Float fPx, Float fPy, Float fPz, Float fPw )
{
	this->x = fPx;
	this->y = fPy;
	this->z = fPz;
	this->w = fPw;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
Float CVector4D::LengthSq( void )
{
	return ((x * x) + (y * y) + (z * z));
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
Float CVector4D::Length( void )
{
	return (Float)sqrt( LengthSq() );
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
Float CVector4D::Dot( CVector4D &In )
{
	return ((x * In.x) + (y * In.y) + (z * In.z));
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::Normalize( CVector4D &In )
{
	Float div = 1.0f / In.Length();
	x = In.x * div;
	y = In.y * div;
	z = In.z * div;
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::Cross( CVector4D &In1, CVector4D &In2 )
{
	x = (In1.y * In2.z) - (In1.z * In2.y);
	y = (In1.z * In2.x) - (In1.x * In2.z);
	z = (In1.x * In2.y) - (In1.y * In2.x);
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::Reflect( CVector4D &In1, CVector4D &In2 )
{
	Float dot = In1.Dot( In2 );

	x = In1.x - (2 * dot * In2.x);
	y = In1.y - (2 * dot * In2.y);
	z = In1.z - (2 * dot * In2.z);
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::TransformNormal( CVector4D &In1, CMatrix &In2 )
{
	x = (In1.x * In2.x.x) + (In1.y * In2.y.x) + (In1.z * In2.z.x);
	y = (In1.x * In2.x.y) + (In1.y * In2.y.y) + (In1.z * In2.z.y);
	z = (In1.x * In2.x.z) + (In1.y * In2.y.z) + (In1.z * In2.z.z);
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::TransformCoord( CVector4D &In1, CMatrix &In2 )
{
	x = (In1.x * In2.x.x) + (In1.y * In2.y.x) + (In1.z * In2.z.x) + (In1.w * In2.w.x);
	y = (In1.x * In2.x.y) + (In1.y * In2.y.y) + (In1.z * In2.z.y) + (In1.w * In2.w.y);
	z = (In1.x * In2.x.z) + (In1.y * In2.y.z) + (In1.z * In2.z.z) + (In1.w * In2.w.z);
	w = (In1.x * In2.x.z) + (In1.y * In2.y.z) + (In1.z * In2.z.z) + (In1.w * In2.w.z);
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::TransformProjection( CVector4D &In1, CMatrix &In2 )
{
	Float _x = (In1.x * In2.x.x) + (In1.y * In2.y.x) + (In1.z * In2.z.x) + (In1.w * In2.w.x);
	Float _y = (In1.x * In2.x.y) + (In1.y * In2.y.y) + (In1.z * In2.z.y) + (In1.w * In2.w.y);
	Float _z = (In1.x * In2.x.z) + (In1.y * In2.y.z) + (In1.z * In2.z.z) + (In1.w * In2.w.z);
	Float _w = (In1.x * In2.x.w) + (In1.y * In2.y.w) + (In1.z * In2.z.w) + (In1.w * In2.w.w);

	w = _w;

	_w = 1.0f / _w;

	x = _x * _w;
	y = _y * _w;
	z = _z * _w;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::Normalize( void )
{
	Float div = 1.0f / Length();
	x *= div;
	y *= div;
	z *= div;
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::Cross( CVector4D &In )
{
	CVector4D vTemp = *this;
	x = (vTemp.y * In.z) - (vTemp.z * In.y);
	y = (vTemp.z * In.x) - (vTemp.x * In.z);
	z = (vTemp.x * In.y) - (vTemp.y * In.x);
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::Reflect( CVector4D &In )
{
	CVector4D vTemp = *this;
	Float dot = In.Dot( vTemp );

	x = In.x - (2 * dot * vTemp.x);
	y = In.y - (2 * dot * vTemp.y);
	z = In.z - (2 * dot * vTemp.z);
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::TransformNormal( CMatrix &In )
{
	CVector4D vTemp = *this;
	x = (vTemp.x * In.x.x) + (vTemp.y * In.y.x) + (vTemp.z * In.z.x);
	y = (vTemp.x * In.x.y) + (vTemp.y * In.y.y) + (vTemp.z * In.z.y);
	z = (vTemp.x * In.x.z) + (vTemp.y * In.y.z) + (vTemp.z * In.z.z);
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::TransformCoord( CMatrix &In )
{
	CVector4D vTemp = *this;
	x = (vTemp.x * In.x.x) + (vTemp.y * In.y.x) + (vTemp.z * In.z.x) + In.w.x;
	y = (vTemp.x * In.x.y) + (vTemp.y * In.y.y) + (vTemp.z * In.z.y) + In.w.y;
	z = (vTemp.x * In.x.z) + (vTemp.y * In.y.z) + (vTemp.z * In.z.z) + In.w.z;
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::TransformProjection( CMatrix &In )
{
	CVector4D vTemp = *this;
	Float _x = (vTemp.x * In.x.x) + (vTemp.y * In.y.x) + (vTemp.z * In.z.x) + In.w.x;
	Float _y = (vTemp.x * In.x.y) + (vTemp.y * In.y.y) + (vTemp.z * In.z.y) + In.w.y;
	Float _z = (vTemp.x * In.x.z) + (vTemp.y * In.y.z) + (vTemp.z * In.z.z) + In.w.z;
	Float _w = (vTemp.x * In.x.w) + (vTemp.y * In.y.w) + (vTemp.z * In.z.w) + In.w.w;

	w = _w;

	_w = 1.0f / _w;

	x = _x * _w;
	y = _y * _w;
	z = _z * _w;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::RotationX( Sint32 Angle )
{
	CVector4D vTemp = *this;
	Float s = Math::Sin( Angle );
	Float c = Math::Cos( Angle );

	x = vTemp.x;
	y = (vTemp.y * +c) + (vTemp.z * -s);
	z = (vTemp.y * +s) + (vTemp.z * +c);
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::RotationY( Sint32 Angle )
{
	CVector4D vTemp = *this;
	Float s = Math::Sin( Angle );
	Float c = Math::Cos( Angle );

	x = (vTemp.x * +c) + (vTemp.z * +s);
	y = vTemp.y;
	z = (vTemp.x * -s) + (vTemp.z * +c);
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::RotationZ( Sint32 Angle )
{
	CVector4D vTemp = *this;
	Float s = Math::Sin( Angle );
	Float c = Math::Cos( Angle );

	x = (vTemp.x * +c) + (vTemp.y * -s);
	y = (vTemp.x * +s) + (vTemp.y * +c);
	z = vTemp.z;
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::RotationAxis( Sint32 Angle, CVector3D &Axis )
{
	CMatrix Mat;
	Mat.RotationAxis( Angle, Axis );
	TransformNormal( Mat );
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::Scaling( Float sx, Float sy, Float sz )
{
	x *= sx;
	y *= sy;
	z *= sz;
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::Translation( Float px, Float py, Float pz )
{
	x += px;
	y += py;
	z += pz;
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::Add( CVector4D &In1, CVector4D &In2 )
{
	x = In1.x + In2.x;
	y = In1.y + In2.y;
	z = In1.z + In2.z;
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::Sub( CVector4D &In1, CVector4D &In2 )
{
	x = In1.x - In2.x;
	y = In1.y - In2.y;
	z = In1.z - In2.z;
	w = 1.0f;
}


//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
void CVector4D::Set( Float fPx, Float fPy, Float fPz )
{
	x = fPx;
	y = fPy;
	z = fPz;
	w = 1.0f;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D &CVector4D::operator += ( const CVector4D& v )
{
    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D &CVector4D::operator -= ( const CVector4D& v )
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D &CVector4D::operator *= ( Float f )
{
    x *= f;
    y *= f;
    z *= f;
    return *this;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D &CVector4D::operator /= ( Float f )
{
    Float fInv = 1.0f / f;
    x *= fInv;
    y *= fInv;
    z *= fInv;
    return *this;
}


//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D CVector4D::operator + () const
{
    return *this;
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D CVector4D::operator - () const
{
    return CVector4D(-x, -y, -z, 1.0f);
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D CVector4D::operator + ( const CVector4D& v ) const
{
    return CVector4D(x + v.x, y + v.y, z + v.z, 1.0f);
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D CVector4D::operator - ( const CVector4D& v ) const
{
    return CVector4D(x - v.x, y - v.y, z - v.z, 1.0f);
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D CVector4D::operator * ( Float f ) const
{
    return CVector4D(x * f, y * f, z * f, 1.0f);
}

//-----------------------------------------------------------------------------------
/**
*/
//-----------------------------------------------------------------------------------
CVector4D CVector4D::operator / ( Float f ) const
{
    Float fInv = 1.0f / f;
    return CVector4D(x * fInv, y * fInv, z * fInv, 1.0f);
}

